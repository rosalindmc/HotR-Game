<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_selection</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i = 1
var ii, ix, iy

//Generates new random seed
randomize()

//Initiative
mapTime = 0
mapTimeOn = true
global.timeDelay = 1
global.target = -4

//Visuals
image_speed = .3
tDir = 0
tID = noone

//Selection
global.control = noone
global.nextChar = noone
actNum = 0 //Variable for number of actions

//Other variables
global.zViewToggle = false

//Create Camera
instance_create(x,y,obj_camera)

//Framerate
room_speed = global.fspd

//Cursor
cIsoX = 0
cIsoY = 0
cIsoZ = 0
cHover = noone
global.zLevel = 0
global.attackFromTile = -4

//Action Control
action = moveControl

//Tile Creation
mapHeight = 10
mapWidth = 10
mapDepth = 3

ix = 0
repeat(mapWidth)
{
    iy = 0
    repeat(mapHeight)
    {
        iz = 0
        repeat(mapDepth)
        {
            map[ix+(mapWidth*iz),iy] = instance_create((room_width/2)+(ix*20)-(iy*20),110+(ix*10)+(iy*10),obj_tile)
            map[ix+(mapWidth*iz),iy].isoX = ix
            map[ix+(mapWidth*iz),iy].isoY = iy
            map[ix+(mapWidth*iz),iy].isoZ = iz
            map[ix+(mapWidth*iz),iy].h = iz*30
            
            if iz != 0
            {
                map[ix+(mapWidth*iz),iy].ground = false 
            }            
            iz += 1
        }   
        iy += 1
    }
    ix += 1
}

//Establish Adjacency
ix = 0
repeat(mapWidth)
{
    iy = 0
    repeat(mapHeight)
    {
        iz = 0
        repeat(mapDepth)
        {
        tile = map[ix+(mapWidth*iz),iy]
        
        //West Adjacency
        if ix &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*iz),iy])
        //East Adjacency
        if ix &lt; mapWidth-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*iz),iy])
        //North Adjacency
        if iy &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*iz),iy-1])
        //South Adjacency
        if iy &lt; mapHeight-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*iz),iy+1])
          
        //North-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*iz),iy-1])     
        //North-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &gt; 0
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*iz),iy-1])
        //South-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &lt; mapHeight-1
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*iz),iy+1])
        //South-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &lt; mapHeight-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*iz),iy+1])
        
        //Down-West Adjacency
        if ix &gt; 0 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz-1)),iy])
        //Down-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz-1)),iy])
        //Down-North Adjacency
        if iy &gt; 0 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz-1)),iy-1])
        //Down-South Adjacency
        if iy &lt; mapHeight-1 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz-1)),iy+1])
        //Down Adjacency
        if iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz-1)),iy])
        
        //Up-West Adjacency
        if ix &gt; 0 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz+1)),iy])
        //Up-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz+1)),iy])
        //Up-North Adjacency
        if iy &gt; 0 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz+1)),iy-1])
        //Up-South Adjacency
        if iy &lt; mapHeight-1 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz+1)),iy+1])
        //Up Adjacency
        if iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz+1)),iy])
        
        iz += 1
        }                              
        iy += 1
    }
    ix += 1
}

//Adjacency After Map Build
alarm[0] = 10
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Reactivate to Check Adjacency
instance_activate_object(obj_tile)

with(obj_tile)
{
    adjacency()
    
    //Clear Up Grid
    if ground = false
    {
        instance_deactivate_object(id)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Controls
key_meleeToggle = keyboard_check(global.meleeToggle)

//Timer 
if mapTimeOn = true and global.nextChar != noone and global.timeDelay = 0
{
    global.newturn = false

    //Advance the Timer
    ii = max(min(1/global.fspd,global.nextChar.delay),0)
    mapTime += ii
    
    //Reduce all intiative timers
    with(obj_initiativeSlot)
    {
        delay -= other.ii
        
        //Select
        if delay &lt;= 0 and id = global.nextChar
        {
            global.control = owner
            global.newturn = true
        }
    }
    
    if global.newturn = true
    {
        with(global.control)
        {
            ii = instance_create(x,y-h-height,obj_descriptor)   
            ii.text = 'READY'
            ii.font = fnt_tiny
            
            other.mapTimeOn = false
            controlled = true
            
            //TEMP player turns
            if readiedAction = false
            {
                script_execute(controlScript)
            }
            else    //TEMP AI turns
            {
                script_execute(readiedAction)
            }
        }
    }
}
else
{
    ii = min(1/global.fspd,global.timeDelay)
    global.timeDelay -= ii
}

//Mouse
x = mouse_x
y = mouse_y
    
cIsoX = floor(((x-100)/40)+((y-100)/20))-25
cIsoY = floor(((y-100)/20)-((x-100)/40))+25
cIsoZ = global.zLevel 

if point_in_rectangle(mouse_x,mouse_y,view_xview+110,view_yview+view_hview-40,view_xview+110+(actNum*20),view_yview+view_hview-20)
{
    cHover = noone
    global.attackFromTile = noone  
}
else if cIsoX &gt;= 0 and cIsoX &lt; mapWidth and cIsoY &gt;= 0 and cIsoY &lt; mapHeight
{
    cHover = map[cIsoX+(cIsoZ*mapWidth),cIsoY]
    depth = cHover.depth-1
}
else
{
    cHover = noone
    global.attackFromTile = noone  
}

//zLevel Scrolling
if mouse_wheel_up() and global.zLevel &lt; mapDepth-1
{
    cIsoZ = cIsoZ+1
    global.zLevel = cIsoZ
    updateScrollVis()
}

if mouse_wheel_down() and global.zLevel &gt; 0
{
    cIsoZ = cIsoZ-1
    global.zLevel = cIsoZ
    updateScrollVis()
}

if mouse_check_button_pressed(mb_middle)
{
    if global.zViewToggle = false
    {
        global.zViewToggle = true
        updateScrollVis()
    }
    else
    {
        global.zViewToggle = false
        updateScrollVis()
    }
}

//Execute current action
if mouse_check_button_pressed(mb_right)
{
    if global.control != noone
    {
        if cHover != noone
        {
            script_execute(action,1)
        }
    }
}

//
//Extra Drawing Stuff
//

//Mouse Sprite
global.mouseSprite = 0

if global.control != noone
{
    //Center Camera
    if keyboard_check_pressed(global.centerKey)
    {
        obj_camera.x = global.control.x
        obj_camera.y = global.control.y
    }

    //Mouse Sprite
    if cHover != noone
    {    
        //Ranged Attack Icon
        if cHover.rangedAttack = true and (key_meleeToggle = false or cHover.meleeAttack = false)
        {
            global.mouseSprite = 2
        }
        
        //Melee Attack Icon
        if cHover.meleeAttack = true and (key_meleeToggle = true or cHover.rangedAttack = false)
        {
            global.mouseSprite = 1
            
            tDir = 360
            
            for(ii = 0; ii &lt; ds_list_size(cHover.walk); ii ++)
            {
                current = ds_list_find_value(cHover.walk, ii)
                
                if current.move = true or current.occupant = global.control
                {
                    if abs(angle_difference(point_direction(mouse_x,mouse_y,cHover.x,cHover.y),point_direction(current.x,current.y,cHover.x,cHover.y))) &lt; tDir
                    {
                        tDir = abs(angle_difference(point_direction(mouse_x,mouse_y,cHover.x,cHover.y),point_direction(current.x,current.y,cHover.x,cHover.y)))
                        tID = current
                    }
                }
            }
            global.attackFromTile = tID
        }
        
        //Pathdrawing
        if action = moveControl
        {
            obj_tile.onPath = false
            
            if global.mouseSprite = 1 and instance_exists(global.attackFromTile)
            {
                i = global.attackFromTile
            }
            else
            {
                i = cHover
            }
            
            if i.move or (i.occupant = global.control and global.mouseSprite = 1)
            {
                i.onPath = 5
                if i.pathParent != noone
                {
                    i = i.pathParent
                    
                    while(i.pathParent != noone)
                    {
                        i.onPath = 4
                        i = i.pathParent
                    }
                }
            }
        }      
    }
}

//Update Visible Tiles
if obj_camera.x != obj_camera.xprevious or obj_camera.y != obj_camera.yprevious
{
    updateScrollVis()
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(fnt_small)
draw_set_halign(fa_right)
drawText(c_black,c_white,view_xview+view_wview-10,view_yview+60,mapTime)
//drawText(c_black,c_white,view_xview+view_wview-10,view_yview+80,cIsoZ)
//drawText(c_black,c_white,view_xview+view_wview-10,view_yview+100,global.zLevel)


//draw_set_colour(c_black)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//UI Players
//scr_playerPortrait(5)

//Highlighted Area
if cHover != noone
{
    if global.mouseSprite = 0
    {
        draw_sprite(spr_selection,image_index,cHover.x,cHover.y-cHover.h+(global.zLevel*30))  
    }
    else
    {
        draw_sprite(spr_enemyselect,image_index,cHover.x,cHover.y-cHover.h+(global.zLevel*30))  
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
