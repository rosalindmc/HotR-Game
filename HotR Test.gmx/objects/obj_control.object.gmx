<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_selection</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i = 1
var ii, ix, iy

//Generates new random seed
randomize()

//Initiative
mapTime = 0
mapTimeOn = true
global.timeDelay = 1
global.target = -4
global.expTotal = 0
global.losCheckFrom = noone
global.follow = noone

//Visuals
image_speed = .3
tDir = 0
tID = noone

//Selection
global.control = noone
global.pathDraw = false
global.nextChar = noone
actNum = 0 //Variable for number of actions

//z variables
global.zViewToggle = true
zViewAlpha = 0

//tooltips
tooltipText = -4
tooltipTitle = -4

//Create Combat HUD
i = instance_create(0,view_hview-120,obj_charInfo)
i.control = id

i = instance_create(x,y,obj_initiativeSlot)
i.testSlot = true
global.testSlot = i
order = 10

//Framerate
room_speed = global.fspd

//Cursor
cIsoX = 0
cIsoY = 0
cIsoZ = 0
cHover = noone
global.zLevel = 0
global.attackFromTile = -4

//Action Control
action = moveControl
actionScroll = action

//Tile Creation
mapHeight = 20
mapWidth = 20
mapDepth = 10

runEvent = -4
eventName = -4
eventLine = -4

ix = 0
repeat(mapWidth)
{
    iy = 0
    repeat(mapHeight)
    {
        iz = 0
        repeat(mapDepth)
        {
            map[ix+(mapWidth*iz),iy] = instance_create((room_width/2)+(ix*20)-(iy*20),110+(ix*10)+(iy*10),obj_tile)
            map[ix+(mapWidth*iz),iy].sprite_index = global.battlefield.tile.sprite_index
            map[ix+(mapWidth*iz),iy].isoX = ix
            map[ix+(mapWidth*iz),iy].isoY = iy
            map[ix+(mapWidth*iz),iy].isoZ = iz
            map[ix+(mapWidth*iz),iy].h = iz*15
            
            if iz != 0
            {
                map[ix+(mapWidth*iz),iy].ground = false 
            }            
            iz += 1
        }   
        iy += 1
    }
    ix += 1
}

//Establish Adjacency
ix = 0
repeat(mapWidth)
{
    iy = 0
    repeat(mapHeight)
    {
        iz = 0
        repeat(mapDepth)
        {
        tile = map[ix+(mapWidth*iz),iy]
        
        //West Adjacency
        if ix &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*iz),iy])
        //East Adjacency
        if ix &lt; mapWidth-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*iz),iy])
        //North Adjacency
        if iy &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*iz),iy-1])
        //South Adjacency
        if iy &lt; mapHeight-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*iz),iy+1])
          
        //North-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*iz),iy-1])     
        //North-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &gt; 0
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*iz),iy-1])
        //South-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &lt; mapHeight-1
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*iz),iy+1])
        //South-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &lt; mapHeight-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*iz),iy+1])
        
        //Down-West Adjacency
        if ix &gt; 0 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz-1)),iy])
        //Down-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz-1)),iy])
        //Down-North Adjacency
        if iy &gt; 0 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz-1)),iy-1])
        //Down-South Adjacency
        if iy &lt; mapHeight-1 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz-1)),iy+1])
        //Down-South-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &lt; mapHeight-1 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz-1)),iy+1])
        //Down-North-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &gt; 0 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz-1)),iy-1])
        //Down-North-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &gt; 0 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz-1)),iy-1])
        //Down-South-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &lt; mapHeight-1 &amp;&amp; iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz-1)),iy+1])
        //Down Adjacency
        if iz &gt; 0
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz-1)),iy])
        
        //Up-West Adjacency
        if ix &gt; 0 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz+1)),iy])
        //Up-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz+1)),iy])
        //Up-North Adjacency
        if iy &gt; 0 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz+1)),iy-1])
        //Up-South Adjacency
        if iy &lt; mapHeight-1 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz+1)),iy+1])
        //Up-South-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &lt; mapHeight-1 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz+1)),iy+1])
        //Up-North-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &gt; 0 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz+1)),iy-1])
        //Up-North-West Adjacency
        if ix &gt; 0 &amp;&amp; iy &gt; 0 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix-1+(mapWidth*(iz+1)),iy-1])
        //Up-South-East Adjacency
        if ix &lt; mapWidth-1 &amp;&amp; iy &lt; mapHeight-1 &amp;&amp; iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+1+(mapWidth*(iz+1)),iy+1])
        //Up Adjacency
        if iz &lt; mapDepth-1
        ds_list_add(tile.adjacent, map[ix+(mapWidth*(iz+1)),iy])
        
        iz += 1
        }                              
        iy += 1
    }
    ix += 1
}

//Adjacency After Map Build
alarm[0] = 10
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>initiativeSlotReset()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Reactivate to Check Adjacency
instance_activate_object(obj_tile)

with(obj_tile)
{
    adjacency()
    
    //Clear Up Grid
    if ground = false
    {
        sprite_index = spr_none
    }

    if ground = false and wall[0] = noone and wall[1] = noone and wall[2] = noone and wall[3] = noone
    {
        instance_deactivate_object(id)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Controls
key_meleeToggle = keyboard_check(global.meleeToggle)

zViewAlpha -= 1/global.fspd

//Timer 
if mapTimeOn = true and global.nextChar != noone and global.timeDelay = 0
{
    global.newturn = false

    //Advance the Timer
    mapTemp = floor(mapTime)
    ii = max(min(1/global.fspd,global.nextChar.delay),0)
    mapTime += ii
    
    //Run Upkeep
    if mapTemp != floor(mapTime)
    {
        with(obj_character)
        {
            triggerOnUpkeep()
        }
    }
    
    //Reduce all intiative timers
    with(obj_initiativeSlot)
    {
        delay -= other.ii
        
        //Select
        if delay &lt;= 0 and id = global.nextChar
        {
            global.control = owner
            global.newturn = true
        }
    }
    
    if global.newturn = true
    {
        with(global.control)
        {
            //ii = instance_create(x,y-h-height,obj_descriptor)   
            //ii.text = 'READY'
            //ii.font = fnt_tiny
            
            other.mapTimeOn = false
            controlled = true
            
            staminaCheck()
            adjacentCharacters()
            iC()
            
            //TEMP player turns
            if readiedAction = false
            {
                script_execute(controlScript)
            }
            else    //TEMP AI turns
            {
                script_execute(readiedAction)
            }
        }
    }
}
else if global.follow = noone
{
    ii = min(1/global.fspd,global.timeDelay)
    global.timeDelay -= ii
}

//Mouse
x = mouse_x
y = mouse_y
    
cIsoX = floor(((x-100)/40)+((y-100)/20))-25
cIsoY = floor(((y-100)/20)-((x-100)/40))+25
cIsoZ = global.zLevel


if cIsoX &gt;= 0 and cIsoX &lt; mapWidth and cIsoY &gt;= 0 and cIsoY &lt; mapHeight
{
    cHover = map[cIsoX+(cIsoZ*mapWidth),cIsoY]
    depth = cHover.depth-500
}
else
{
    cHover = noone
    global.attackFromTile = noone  
}

//Mouse Canceling
if point_in_rectangle(mouse_x,mouse_y,view_xview+130,view_yview+view_hview-40,view_xview+130+(actNum*20),view_yview+view_hview-20)
or (global.nextChar.owner.player = true and point_in_rectangle(mouse_x,mouse_y,view_xview,view_yview+view_hview-120,view_xview+110,view_yview+view_hview))
{
    cHover = noone
    global.attackFromTile = noone  
}
else
{
    tooltipTitle = -4
}

if point_in_rectangle(mouse_x,mouse_y,view_xview+130,view_yview+view_hview-40,view_xview+130+(actNum*20),view_yview+view_hview-20)
{
    if instance_exists(collision_point(mouse_x,mouse_y,obj_actionButton,false,false))
    {
        actionScroll = collision_point(mouse_x,mouse_y,obj_actionButton,false,false).action
    }
}
else
{
    actionScroll = action
}

//zLevel Scrolling
if mouse_wheel_up() and global.zLevel &lt; mapDepth-1
{
    cIsoZ = cIsoZ+1
    global.zLevel = cIsoZ
    zViewAlpha = 3
    updateScrollVis()
}

if mouse_wheel_down() and global.zLevel &gt; 0
{
    cIsoZ = cIsoZ-1
    global.zLevel = cIsoZ
    zViewAlpha = 3
    updateScrollVis()
}

if mouse_check_button_pressed(mb_middle)
{
    if global.zViewToggle = false
    {
        global.zViewToggle = true
        updateScrollVis()
    }
    else
    {
        global.zViewToggle = false
        updateScrollVis()
    }
}

//Execute current action
if mouse_check_button_pressed(mb_right)
{
    if global.control != noone
    {
        if cHover != noone
        {
            script_execute(action,1)
        }
    }
}

//
//Extra Drawing Stuff
//

//Mouse Sprite
global.mouseSprite = 0

if global.control != noone
{
    //Center Camera
    if keyboard_check_pressed(global.centerKey)
    {
        obj_camera.x = global.control.x
        obj_camera.y = global.control.y
        cIsoZ = global.control.isoZ
        global.zLevel = cIsoZ
        zViewAlpha = 3
    }

    //Mouse Sprite
    if cHover != noone
    {    
        //Ranged Attack Icon
        if cHover.rangedAttack = true and (key_meleeToggle = false or cHover.meleeAttack = false)
        {
            global.mouseSprite = 2
        }
        
        //Melee Attack Icon
        if cHover.meleeAttack = true and (key_meleeToggle = true or cHover.rangedAttack = false)
        {
            global.mouseSprite = 1
            

            
            if action = battle
            {
                global.attackFromTile = global.control.isoTile        
            }
            else
            {
            tDir = 360
            
            for(ii = 0; ii &lt; ds_list_size(cHover.walk); ii ++)
            {
                current = ds_list_find_value(cHover.walk, ii)
                
                if current.move = true or current.occupant = global.control
                {
                    if abs(angle_difference(point_direction(mouse_x,mouse_y,cHover.x,cHover.y),point_direction(current.x,current.y,cHover.x,cHover.y))) &lt; tDir
                    {
                        tDir = abs(angle_difference(point_direction(mouse_x,mouse_y,cHover.x,cHover.y),point_direction(current.x,current.y,cHover.x,cHover.y)))
                        tID = current
                    }
                }
            }
            global.attackFromTile = tID
            }
        }
        
        //Pathdrawing
        if global.pathDraw = true
        {
            obj_tile.onPath = false
            
            if global.mouseSprite = 1 and instance_exists(global.attackFromTile)
            {
                i = global.attackFromTile
            }
            else
            {
                i = cHover
            }
            
            if i.move or (i.occupant = global.control and global.mouseSprite = 1)
            {
                i.onPath = 5+cHover.meleeAttack
                if i.pathParent != noone
                {
                    i = i.pathParent
                    
                    while(i.pathParent != noone)
                    {
                        i.onPath = 4
                        i = i.pathParent
                    }
                }
            }
        }      
    }
}

if instance_exists(global.follow)
{
    obj_camera.x = global.follow.x
    obj_camera.y = global.follow.y
}
else
{
    global.follow = noone
}


//Update Visible Tiles
if obj_camera.x != obj_camera.xprevious or obj_camera.y != obj_camera.yprevious
{
    updateScrollVis()
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(fnt_small)
draw_set_halign(fa_right)
draw_set_valign(fa_middle)
drawText(c_black,c_white,view_xview+view_wview-10,view_yview+60,mapTime)

abilityTooltip()

if global.timeDelay = 0 and global.nextChar.owner.player = true
{   
    script_execute(actionScroll,2)
}  

if zViewAlpha &gt; 0
{
    draw_set_alpha(zViewAlpha)

    draw_set_valign(fa_center)
    draw_set_halign(fa_right)
    draw_set_font(fnt_tiny)
    drawText(c_black,c_white,view_xview+view_wview-125,view_yview+view_hview-80,'Z')
    draw_set_halign(fa_left)
    draw_set_font(fnt_main)
    drawText(c_black,c_white,view_xview+view_wview-120,view_yview+view_hview-80,global.zLevel)
    
    draw_set_alpha(1)
}
     /* 
if cHover != noone
{
    with(cHover)
    {
    drawText(c_black,c_white,x,y,ground)
    }
    drawText(c_black,c_white,x,y+20,cHover.wall[0])
    drawText(c_black,c_white,x,y+40,cHover.wall[1])
    drawText(c_black,c_white,x,y+60,cHover.wall[2])
    drawText(c_black,c_white,x,y+80,cHover.wall[3])
    
    if global.losCheckFrom != noone
    {
        losCheck(40,global.losCheckFrom,cHover.sightTile)
    }
    
    if mouse_check_button_pressed(mb_left)
    {
        global.losCheckFrom = cHover.sightTile
    }
}

if cHover != noone
{
    drawText(c_black,c_white,x,y,map[cHover.isoX,cHover.isoY].heightMap)
}
    
//drawText(c_black,c_white,view_xview+view_wview-10,view_yview+100,global.battlefield.tile.humidity)
//drawText(c_black,c_white,view_xview+view_wview-10,view_yview+140,global.battlefield.tile.height)


//draw_set_colour(c_black)

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//UI Players
//scr_playerPortrait(5)

//Highlighted Area
if cHover != noone
{
    if global.mouseSprite = 0
    {
        draw_sprite(spr_selection,image_index,cHover.x,cHover.y-cHover.h+(global.zLevel*15))
        //draw_sprite_ext(spr_selection,image_index,cHover.x,cHover.y-30-cHover.h+(global.zLevel*30),1,-1,0,c_white,1)  
    }
    else
    {
        draw_sprite(spr_enemyselect,image_index,cHover.x,cHover.y-cHover.h+(global.zLevel*15))  
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
